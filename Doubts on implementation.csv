Please go through day10 and day11 zip files before asking any doubts. Also check man pages before asking questions.,,,,,
Name (optional),Doubt,Response,,,
,"Is there any specific way/format you want us to store in the file, or is anyway we find suitable and working acceptable?","First the header which occupies sizeof(tree_t) bytes. And then followed by tree nodes. If I call add new node and the free list is empty, then add the new node to the end of the file (which would increase the filesize by sizeof(node_t) bytes)",,,
,What is the maximum number of elements to be stored in the tree?,No assumption as such.,,,
,"To keep the changes made to the file seamless and up to date every now and then, can we reopen the fp at the start and close it at the end of every change involving function?","Not sure why you think this would be required. When I mentioned I'll close and restart the program, I meant I'll call close_tree to safely close the file so all the changes are synced to the disk. Also how would you call fopen in every function; I'll be passing the filename only to init_tree function.",,,
,Could you explain the use of 'free_head' variable in detail?,"Suppose you already have a tree in a file. So, the file looks something like this: header followed by some number of nodes. Assume that right now I haven't ever called delete node function, so your free list will be empty. Now suppose, I call delete node and that node is somewhere in the middle of the file. This node would now be invalid, and won't be a part of the tree anymore. You won't be shifting the rest of the data to fill in this hole (imagine all the offsets you'd have to change and the complex logic you'd have to write). So, now what you can do is, keep a track of all these free nodes in a linked list. To make a list, you can use the logic I've put in the doc. Whenever I call add new node, you'll check whether you can use up a node from the free list, so instead of growing the file size, you'll just use one of the invalidated nodes.",,,
,So filename should be accepted from the terminal?,Filename will be passed to init_tree function. Please go through the header file.,,,
,"Regarding q6 will you be creating the new file first,closing the program and then running the program with the menu driven option?","We won't be using a menu driven approach. You guys don't have to worry about what's going to happen on client side. Just implement the functions mentioned in the interface. As for init_tree, I hope the description is clear: we'll pass in a filename, if the file exists (it means a tree already exists), just open the file and return the file ptr, if it doesn't exist, create a file with that filename and fwrite/put the header structure in there with it's values grounded to indicate empty tree.",,,
,So q5's response means that free_head will be used to determine whether a certain node is free to be deleted or not?,"No, check the response again.",,,
,"If you're deleting a node and adding it to the free list, then how'll you reuse it? ","Please think about what deleting a node in this context means. It's not the same as free(node) that you'd normally call in a BST program. In this case you basically have a hole of sizeof(node_t) bytes in between some useful data. By adding to the free list, all I mean is, you'll update one of the left or right offsets to point to old free_head's value and the new free_head's value will be the offset to this invalidated node. When it comes to reusing this hole, when I call add new node check if this free_head's list is empty or not, if not just use up a node to make this the new node.",,,
,And lastly what'll be free_head's initial value?,All invalid offsets can be respresented using -1. So -1 logically should be free_head's initial value.,,,
,I'm sorry but the free_head concept is still unclear.Could you please include an example in the FT-4 google docs?Like how it was done for the previous ones?,"Please read the other responses, and if it's still not clear then mail us.",,,
,"How will you insert a new node, if the root value keeps changing? Shouldn't we go through the tree, from the starting index, to determine the actual postion of this new node. Or will we be making the header_t.root a constant node, poinint to the root of the tree, and creating a copy of this root value and changing that  while inserting/displaying/deleting. ","See, this entire thing is the same as your usual binary search tree implementation. Just that, instead of pointers you're using integer offsets. Since the root can change you'll just change the root offset value in the header to indicate the new root. The new root's actual position with the data could be anywhere down the file.",,,
,"Just as how you explained free_head in detail, please explain the role of root in detail ","See, this entire thing is the same as your usual binary search tree implementation. Just that, instead of pointers you're using integer offsets. Since the root can change you'll just change the root offset value in the header to indicate the new root. The new root's actual position with the data could be anywhere down the file.",,,
,"Instead of creating a list of free nodes, can we use the logic where the free_head has offset to the first free location, and that free location has the offset of the next free location and so on. So we can itially make the value of free_head as sizeof(tree_t). This way we wouldn't need to create a separate list right. Also since we do not know the number of free spaces that are going to be there, it will be difficult to keep changing the size of the list as the number of free spaces keeps increasing.","Isn't whatever you're suggesting same as a list itself? By list I meant linked list itself, not an array of some fixed size. Also, you can try the method you're suggesting where you initially have it as sizeof(tree_t) but there could be a possibility of segfault; if it works, well and good. ",,,
,what if in the case where the node you want to delete is a parent node? should we do the replacing with max/min node of a sub tree,Do what has been taught in algorithms course which I believe is they've taught you to replace the parent with inorder successor. https://en.wikipedia.org/wiki/Binary_search_tree#Deletion,,,
,Should we use txt file or dat file to store the nodes? Because txt file would be easier to visualize but dat file may be easier to write to,Please try to understand that this assignment is all about writing arbitrary binary data (and not some simple text data) to a file using fwrite and fread. This arbitrary binary data is the same representation that your program structures will have while in memory (RAM). File extensions have no meaning when it comes to functionality. You don't have to worry about file extensions as we'll be giving you guys the filename.,,,
,,"Check man pages for fopen and fwrite. Yes, fwrite increases the size of file if you seek to the end and write. Yes it is better to fseek to desired position before fread or fwrite unless you know you want to just read sequentially.",,,
,"Wont the preorder/inorder defeat the purpose of storing bst on disk because we need to stack up the nodes(internal stack if recursion is used or explicit stack if iteration is used)? This stack will use up main memory and if the bst is heavily skewed(fully linear to one side), then we are stll facing the limitation of main memory being small to not accomadate all the nodes",The preorder and inorder functions are there to evaluate your programs. Whatever you're saying is correct. For the assignment you can do the usual recursive implementation of preorder and inorder.,,,
,"So, just to make things clear, the root in the header should be updated every time during the change of the same at the time of insertion/deletion/displaying",Why would the root change during displaying? It is like normal BST program. Change it whenever the pointer to root would change in a normal BST program.,,,
,Can we delete in order successor and add it to free list?,I'm not sure I completely understand your question. Any deleted node should be added to the free list. ,,,
,"Initially while writing the tree into the file, in what order should we put it?",If your free list is empty just add any new node to the end of the file. ,,,
,,,,,
,"Wrt q21, while deleting a key, can we exchange inorder successor and the node to be deleted, and then add inorder successor to the free list as done in our 3rd sem?","Sure, you could do that, but make sure you change the offsets of that old inorder successor node's parent accordingly.",,,
,"While writing the tree into the file for the first time, should it be in preorder or postorder?","You are not writing the tree in either preorder or postorder to the file. You just need to follow a simple rule while writing the nodes to the file, if the free list is empty add the new node to the end of the file, if it's not then utilize the free list to get the offset of the node and write it there.",,,
,If the file already exists in which a tree is present we dont have the free_list does that mean at the end of every program we have to append the free_list to the file,"No. free_list is not a separate structure you'd append to the file. Thing is, in a linked list you have nodes right? Same thing here, you already have nodes but those nodes initially would've belonged to the tree, but after deletion they'll just belong to the linked list. If free_list head is -1 it just means no node has been deleted from the tree yet or maybe all the past-deleted nodes were used up.",,,
,The size of the file never decreases right?,No. It doesn't.,,,
,Does the format or type of the file we are writing in matter?,No it doesn't. fwrite just dumps x bytes of binary data from the source pointer to the file at whichever offset the file pointer is currently at.,,,
,What is the output format you expect?,I have mentioned the output format of inorder and preorder if that's what you're asking.,,,
,what is the use of free_head and root. i got to know that the root points to the root of the tree but what is the use of free_head because for insertion we have multiple places,free_head is the head of a linked list that you'd make using those binary tree nodes that have been deleted from the tree. Please read other queries regarding this and let us know if it's answered why we're having this concept of a linked list ,,,
,"Could we read everything from the file, perform the given operations and write the updates values into the file? Or would that defeat the purpose of the assignment?",That would defeat the purpose of the assignment. You're going to only work with handful number of nodes at a time from the file and not load the entire tree onto the memory (except for preorder and inorder functions as pointed out in some other query).,,,
,"Can the offset field (left_offset and right_offset) contain the number of bytes from the beginning of the file rather than the position (position as in 1st node, 2nd node, etc)?",That's exactly what they contain. That's what the offset means. Offset is the number of bytes from the beginning of the file.,,,
,its ok if we use many user defined functions reight??,Sure.,,,
,Can we add a node while initialising the list? And can we keep an extra node in the list always? And basically make the free_head identify that node if there are no other holes?,Sure.,,,
,"wrt q31, is it ok to store offset as ints like 0,1,2 etc indicating the 0th node, 1st node, 2nd node below the header? While fseeking, I will fseek appropriately by multiplying the int offset with node_t size","You can but you'll make it harder for yourself because everytime you want to fseek to a particular node, you'd have to add header bytes and then multiply with whichever nth node you want to go to.",,,
,"For inorder, can we call our own inorder function, from the function that has been provided for us, so that we can use recursion which is not possible using the function definition we have been provided with?",Yeah.,,,
,Can we write our own logic on how to fill up the holes in the file? I may not make my free_head point to the deleted but I will make sure it points to a hole in the file which will be filled up with the next insertion. Is that alright?,Yeah.,,,
,Will values such as -1 be inserted in the tree? It would be difficult to invalidate nodes in such cases and alternatives woud have to be found to making keys equal to -1,Why wouldn't -1 be inserted? Your implementation shouldn't wonder about what value the user will enter for his data part. Not sure why would that make anything difficult. ,,,
,Should the linked list for free nodes implement FIFO or LIFO ?,Whichever is easier. Since adding a new node to the head will be easier so LIFO.,,,
,"I'm sorry this is not a doubt regarding this assignment, but when could we expect our assignment 2 and 3 marks?",,,,
,Can we can implement the insertion and deletion operations iteratively as well?,Yeah.,,,
," A dat file written by one guy with his code, cannot be read by my code right?? its because we both might be storing offsets differently. For example if he has stored an offset as 32, and i try to fseek(fp, 32, SEEK_SET) it wont work for me, but instead fseek(fp, 3, SEEK_SET) will work for me. (size(tree)+(3-1)*size(node)) = 32. His offset implementation and my offset implementation will still point to the same key though. ","Yes, that's true. I didn't give a fixed way of defining the .dat file. Usually, all files have a standard structure. Imagine how the same pdf file can be loaded by different pdf readers.",,,
,"If not -1, could you specify some default value which won't be entered as we will have to set a default value for null elements as null is not defined for integers.(for deletion purposes)","Like I said, you cannot assume any value for the data field in the structure. The user/client can store whatever he wants. Still not convinced why you'd need such an implementation.",,,
,Just wanted to confim. The file just stores the numbers (and their offsets) in the order they were inserted or depending on where they could find free holes right? Inorder and preorder comes to play only when loading the numbers from the file and displaying right?,Yes and yes.,,, 
,Do we have to print if file didn't open correctly or if the tree doesn't have the key to be deleted or already has the key to be inserted etc?,No.,,,
,Is it fine if number of lines of code is around 450?,Yes.,,,
,Is it fine if number of lines of code is around 3500?,,,,
,Do we really have to use Linked List to store the information regarding the free nodes? Is it fine if we use the right offset of the free nodes to store the location of the next free nodes? I've done it that way,"
That's exactly what I meant by the document. You can use either the left or right offset to make the linked list. You don't need to explicitly make a standard linked list node.",,,
,"In continuation to cell 42, ok, like we need a prev pointer which generally points to null, now instead of null their should be some default pointer which won't be accessed.","For the offset field, if you want to represent null, you can use -1. I've mentioned the same countless times. Offsets in a file are the same as pointers in memory.",,,
,"Also, can we show ""key not found"" and ""empty list"" and like ""failed opening using r+"" when something fails on the user end ?",Already answered. Don't do it.,,,
,"On windows (using mingw) when 10 is inserted as a value, that node takes up 13 bytes instead of 12. This happened to my friends too. What's the reason and how to fix it.   On an unbunt system, the same code shows no issues when 10 is inserted.","This is not an issue as long as the code behaves the same as it does with a different compiler on a different machine. This just means you cannot reuse that .dat file with a different executable. The size of data types and structures is compiler dependent unless you use int32_t or int64_t types along with appropriate directives to pack the structure. So, in short don't worry about it as long as it behaves correctly.",,,
,Please give extension of deadline,,,,
,Please give extension of deadline,,,,
,With respect to query 50. The size difference happens for the value 10 only.No other value creates an issue.But I have no idea as to why its happening.,,,,
,With respect to query 50 is it fine if the code behaves correctly using an online compiler.,Try to make sure it works fine on ubuntu.,,,
,"if i have N nodes in the tree, i delete all of them. and then when i insert N+1 nodes into  the tree, the offset of the (N+1)th node is negative. Everything works fine though. Is that normal ??",That seems like an unwanted behaviour. Probably some issue with your code. ,,,
,Extend the deadline please,,,,
,Sir please extend the deadline ,,,,
,Can you please extend the deadline?,,,,
,Sir can you extend the deadline for 2 days?,,,,
,Sir can you extend the deadline?,,,,
,"Yes, please extend the deadline",,,,
,"This is not a doubt, this is to help the Windows users like myself with issues. Open the file in binary format explicitly, using rb+ or wb+. In the default text format, a newline character is, by default, inserted sometimes, which gives that extra byte in the file. This is apparently not an issue in other OS.",,,,
,Can we assume that maximum height of the tree is 25 because after that it gives recurtion depth reached?,Please don't assume anything. Recursion depth depends on the system. ,,,
,"If there is nothing in tree for pre-order and inorder do we need to display ""\n""?",,,,
,Is it required to truncate the file and initialise a new tree if all nodes have been deleted?,No.,,,
,"
It is asked that the first structure in the file will be the header indicating the offset to the root node and offset to the linked list of free nodes. But the structure in the header file has freehead first. Will that be a problem?
",No. I implied the same thing. Header in general contains the two. Order isn't important for the user/client/me.,,,
,Please extend the deadline,,,,
,Yeah bro just by a day extend the deadline,,,,
,please extend the deadline sir,,,,
,I'm mentally exhausted just one more day please,,,,
,"After completing insertion or deletion, the file size is not getting updated(which is known by right click and properties) but it gets updated as soon as display is executed (and this happens upon refreshing the folder which contains the file). Is this lag fine?","Yes, it's fine. You'll understand why this 'lag' is there once you've understood DDCO, MPCA and OS.",,,
,"Should we print ""\n"" for pre-order or inorder if the tree is empty? ",Yeah.,,,
,If I delete the a node with two child then there two options to connect the inorder predecessor or successor and That makes the preorder traversal different for both strategies but inorder traversal will remain the same . Does that matter ,"Yeah, check q16. I'd prefer it to be inorder successor if possible (unless you've already done predecessor) because it'll make it easier for us to check.",,,
,Will the values of tree be only integers of floating point numbers also?,"Check the header file. The key (data) field is an integer. So, for this assignment, it's just an integer.",,,